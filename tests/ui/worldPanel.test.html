<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>World Panel UI Tests</title>
    <link rel="stylesheet" href="../../vendor/mocha.css" />
    <link rel="stylesheet" href="../../vendor/webix.css" />
    <link rel="stylesheet" href="../../assets/css/app.css" />
  </head>
  <body class="testing">
    <div id="mocha"></div>
    <div id="app-root"></div>
    <script src="../../vendor/mocha.js"></script>
    <script src="../../vendor/chai.js"></script>
    <script src="../../vendor/webix.js"></script>
    <script type="module">
      const { expect } = chai;
      mocha.setup("bdd");
      window.addEventListener("error", (event) => {
        console.error("[window error]", event.message, event.filename, event.lineno);
      });
      window.addEventListener("unhandledrejection", (event) => {
        console.error("[unhandled rejection]", event.reason);
      });

      async function loadApp() {
        await import("../../assets/js/app.js");
      }

      function waitForHarness() {
        return new Promise((resolve) => {
          const check = () => {
            if (window.AppHarness) {
              resolve(window.AppHarness);
            } else {
              setTimeout(check, 30);
            }
          };
          check();
        });
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function run() {
        loadApp().then(waitForHarness).then((harness) => {
          describe("World Panel Integration", () => {
            it("zeigt das World Panel nach Auswahl des Knotens", async () => {
              harness.createWorld({ worldName: "Test Harness", worldSize: 4096, worldHeight: 512 });
              await harness.selectNode("world");
              const activeId = harness.getActivePanelId();
              expect(activeId).to.equal("panel-world");
              const worldForm = webix.$$("worldSettingsForm");
              expect(worldForm).to.not.equal(undefined);
              expect(worldForm.isVisible && worldForm.isVisible()).to.equal(true);
            });

            it("updated Noise Heightmap names appear in tree", async () => {
              harness.createWorld({ worldName: "NoiseTest", worldSize: 512, worldHeight: 256 });
              const nodeId = harness.createHeightmap({ bucket: "twoD", mapType: "noise" });
              await harness.selectNode(nodeId);
              const nameFieldId = `noiseField-${nodeId}-displayName`;
              const nameField = webix.$$(nameFieldId);
              expect(nameField).to.not.equal(undefined);
              nameField.setValue("My Noise Layer");
              await sleep(50);
              const tree = webix.$$("navigation");
              expect(tree.getItem(nodeId).value).to.equal("My Noise Layer");
            });

            it("updates Upload Heightmap names and toggles min/max with normalize", async () => {
              harness.createWorld({ worldName: "UploadTest", worldSize: 512, worldHeight: 256 });
              const nodeId = harness.createHeightmap({ bucket: "twoD", mapType: "upload" });
              await harness.selectNode(nodeId);
              const baseId = `uploadHeightmapForm-${nodeId}`;
              const nameField = webix.$$(`${baseId}-displayName`);
              expect(nameField).to.not.equal(undefined);
              nameField.setValue("Imported Terrain");
              await sleep(50);
              const tree = webix.$$("navigation");
              expect(tree.getItem(nodeId).value).to.equal("Imported Terrain");

              const minField = webix.$$(`${baseId}-minValue`);
              const maxField = webix.$$(`${baseId}-maxValue`);
              const normalizeField = webix.$$(`${baseId}-normalize`);
              expect(minField.isEnabled()).to.equal(true);
              expect(maxField.isEnabled()).to.equal(true);
              normalizeField.setValue(1);
              await sleep(30);
              expect(minField.isEnabled()).to.equal(false);
              expect(maxField.isEnabled()).to.equal(false);
              normalizeField.setValue(0);
              await sleep(30);
              expect(minField.isEnabled()).to.equal(true);
              expect(maxField.isEnabled()).to.equal(true);
            });
          });

          mocha.run((failures) => {
            const status = failures ? 1 : 0;
            document.body.setAttribute("data-test-result", status);
            console.log(`TEST_RESULT:${status}`);
          });
        });
      }

      if (document.readyState === "complete" || document.readyState === "interactive") {
        run();
      } else {
        window.addEventListener("DOMContentLoaded", run);
      }
    </script>
  </body>
</html>
